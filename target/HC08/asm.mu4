( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Assembler for Freescale HC08/HCS08 microcontrollers.)

cr " HC08 assembler " file[#

forth
-:  ."  (assembling)"  ;
-:  .assembler. find  if  execute ^  then
        .forth. find  if  execute ^  then  ( XXX broken!! only for test)
       .target. find  if  execute ^  then  number ;
mode asm

-:  ."  (outside)"  ;
-:    .outside. find  if  execute ^  then  number ;
mode outside-loop

-:  ."  (assembling a macro)"  ;
-:   .compiler. find  if  execute ^ then
    .assembler. find  if  compile, ^  then  number literal ;
mode macro-loop

hex  ( it rules!)

forth
: .h  radix @ push  hex <# # # #> type space  pop radix ! ;
-- defer b,  ( so other code can decide how and where code gets assembled)
          ( XXX: is this necessary? |c! is already deferred...)
: b,  .h cr ;
: w,  ( w)  dup 8 u>> b,  b, ;  ( big endian!)


( The bulk of errors are using an illegal operand - H register or
  addressing mode - for a particular type of instruction. Hence:)
: ill   error" illegal operand" ;
 
comment
===========================================================================
One operand addressing modes, by column
    30 direct - 8 bit absolute
    40 A reg
    50 X reg
    60 IX1 - indexed by HX, 8 bit offset
  9E60 SP1 - indexed by SP, 8 bit offset
    70 IX  - indexed by HX, no offset

Two operand addressing modes, by column
    A0 immediate
    B0 direct - 8 bit absolute
    C0 extended - 16 bit absolute
    D0 IX2 - indexed by HX, 16 bit offset
  9ED0 SP2 - indexed by SP, 16 bit offset
    E0 IX1 - indexed by HX, 8 bit offset
  9EE0 SP1 - indexed by SP, 8 bit offset
    F0 IX  - indexed by HX, no offset

We add the following "fake" column for instructions on H reg, of which
there are only three: clrh, pshh, pulh
For consistency we create an inherent ".h" mode.
    80 H reg
===========================================================================

( Addressing modes)

( The indexing words by default create two-op values. The one-op code has
  to convert them and check for illegal addressing modes.)

a0 constant imm
b0 constant dir
c0 constant ext
d0 constant ix2  9ed0 constant sp2
e0 constant ix1  9ee0 constant sp1
f0 constant ix

: u8?  ( u - u flag)  dup 100 u< ;  ( if unsigned value fits in 8 bits)
: s8?  ( n - n flag)  dup 80 + 100 u< ;  ( if signed offset fits into 8 bits)

assembler
: )   ( a - a op)  u8? if dir ^ then  ext ;
: #   ( n - n op)  imm ;
: ,s  ( offset - offset' op)
   ( adjusts offset by 1 since hardware stack is empty descending)
               1+  u8? if sp1 ^ then  sp2 ;
: ,x  ( offset - offset op | op)
   =if ( nonzero)  u8? if ix1 ^ then  ix2 ^ then  drop ( 0) ix ;

30 constant .h  ( fake column)
40 constant .a
50 constant .x
forth

: >col  ( col - index)  4 u>>  0f and ;

( Relative branches.)

( Branch offsets are relative to the _following_ instruction, which starts
  right after the offset, which is always the last byte.)

: >rel  ( dest - offset)  |here 1+ ( src)  -
   s8? not if error" relative branch out of range" then ;

: disp8,  >rel b, ;

forth
: inh  constant does> b, ; ( "inherent")
assembler
80 inh rti
81 inh rts
( 82)
83 inh swi
84 inh tap
85 inh tpa
forth
86 inh _pula  ( .a pul)  ( we'd like one syntax with these and 1ops)
87 inh _psha  ( .a psh)
88 inh _pulx  ( .x pul)
89 inh _pshx  ( .x psh)
8a inh _pulh  ( .h pul)
8b inh _pshh  ( .h psh)
8c inh _clrh  ( .h clr)
assembler
( 8d)
8e inh stop
8f inh wait

( Now the visible pul and psh)
: pul  >col  .h -  dup 3 u< if  jump  _pulh  _pula  _pulx  then  ill ;
: psh  >col  .h -  dup 3 u< if  jump  _pshh  _psha  _pshx  then  ill ;

( 90-93 are bge/blt/bgt/ble)
94 inh txs
95 inh tsx
( 96)
97 inh tax
98 inh clc
99 inh sec
9a inh cli
9b inh sei
9c inh rsp  ( reset stack pointer to 00FF - for HC05 compat)
9d inh nop
( 9e - prebyte for SP indexing, and fancy indexed modes for S08 ld/st/cphx)
9f inh txa


forth
: op,  u8? if b, ^ then  w, ;  ( output op, including pre-byte)
: ea,  ( col)  40 - >col  jump
   ( 40   50   60   70   80   90   a0   b0   c0   d0   e0   f0
     .a   .x   --   --   .h   --  imm  dir  ext  ix2  ix1   ix)
    nope nope ill  ill  ill  ill   b,   b,   w,   w,   b,  nope   [

( What 1colCheck is a bit subtle. Addressing modes that actually address
  memory, rather than specify a register, are represented by the column
  number in the address, including the possible pre-byte - or SP-relative
  modes - in the high byte. But not all modes that are allowed for 2ops are
  allowed for 1ops. So we have to check, convert it to the correct 1op
  column, and also dup it if necessary, so that after compiling the opcode
  we still have a reference to the address mode, so we can compile the
  correct bits after it!

  Laying it all out in a jump table makes it really simple to see what is
  going on.)

: ok  dup ;  ( ok as is; don't convert - this is already a 1col mode)
: cv  ( col - col2 col1)  dup  80 - ;  ( convert and dup)
: 1colCheck  ( col - 2col 1col | col)  ( make sure address mode is allowed)
   dup  40 - >col  jump
   ( 40   50   60   70   80   90   a0   b0   c0   d0   e0   f0
     .a   .x   --   --   .h   --  imm  dir  ext  ix2  ix1   ix)
     ok   ok  ill  ill  ill  ill  ill   cv  ill  ill   cv   cv   [

: 1op  constant does>  ( col row)  or  1colCheck  op, ea, ;
assembler
00 1op neg
forth
01 1op _cbeq ( special)
assembler
( 02 - mul, div, nsa, daa)
  42 inh mul
  52 inh div
  62 inh nsa  ( nybble swap accum)
  72 inh daa  ( decimal adjust accum)
03 1op com
04 1op lsr
( 05 - sthx, ldhx, cphx)
06 1op ror
07 1op asr
08 1op lsl
09 1op rol
0a 1op dec
forth
0b 1op _dbnz ( special)
assembler
0c 1op inc
0d 1op tst
( 0e - mov) 
forth
0f 1op _clr  ( so we can deal with .h clr special case)
assembler

( 1ops with special cases.)
: clr  dup .h = if  drop _clrh ^ then  _clr ;
: dbnz  _dbnz disp8, ;

forth
: 2op  constant does> ( 2col row)  or  dup op,  ea, ;
assembler
00 2op sub
01 2op cmp
02 2op sbc
03 2op cpx
04 2op and
05 2op bit
06 2op lda
07 2op sta  ( imm is ais)
08 2op eor
09 2op adc
0a 2op ora
0b 2op add
0c 2op jmp  ( no imm, no off s)
0d 2op jsr  ( bsr is imm, no off s)
0e 2op ldx
0f 2op stx  ( imm is aix)

: ais  ( n imm )  \a sta ;
: aix  ( n imm )  \a stx ;

forth
: bit  constant does> ;
( Note: These are _hex_ instruction values! The sets are even; the clrs are
  odd.)
00 bit _brset
01 bit _brclr
assembler
10 bit bset
11 bit bclr
: brset  _brset disp8, ;  ( these are branches, so compile the offset too)
: brclr  _brclr disp8, ;

forth
: cond  constant does> ;
assembler
02 cond u>  ( bhi  - C or Z clear)
05 cond u<  ( bcs  - C set)
07 cond eq  ( beq  - Z set)
09 cond hc  ( bhcs - HC set - half carry )
0b cond 0<  ( bmi  - S set)
0d cond xx  ( bms  - I set - interrupt mask)
0f cond xx  ( bih  - irq pin high)
91 cond <   ( blt  - N xor V set)
92 cond >   ( bgt  - Z or [N xor V] clear)
comment ^^^
macro u<=  u> not ;m
macro u>=  u< not ;m
macro  <=   > not ;m
macro  >=   < not ;m  ^^^

( Put this into _if_ rather than in the cond values. Less confusing.)
( Because we'll be using these in if/then, the condition represented is the
  _negative_ of the one in the opcode map.)
: not  ( cond - neg_cond)  1 xor ;

#]file

