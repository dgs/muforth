( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2009 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( Assembler for Freescale HC08/HCS08 microcontrollers.)

cr " HC08 assembler " file[#

forth
-:  ."  (assembling)"  ;
-:  .assembler. find  if  execute ^  then
        .forth. find  if  execute ^  then  ( XXX broken!! only for test)
       .target. find  if  execute ^  then  number ;
mode asm

-:  ."  (outside)"  ;
-:    .outside. find  if  execute ^  then  number ;
mode outside-loop

-:  ."  (assembling a macro)"  ;
-:   .compiler. find  if  execute ^ then
    .assembler. find  if  compile, ^  then  number literal ;
mode macro-loop

hex  ( it rules!)

forth
: .h  radix @ push  hex <# # # #> type space  pop radix ! ;
-- defer b,  ( so other code can decide how and where code gets assembled)
          ( XXX: is this necessary? |c! is already deferred...)
: b,  .h cr  1 |h +! ( so branches will be righter) ;
: w,  ( w)  dup 8 u>> b,  b, ;  ( big endian!)


( The bulk of errors are using an illegal operand - H register or
  addressing mode - for a particular type of instruction. Hence:)
: ill   error" illegal operand" ;
 
comment
===========================================================================
One operand addressing modes, by column
    30 direct - 8 bit absolute
    40 A reg
    50 X reg
    60 IX1 - indexed by HX, 8 bit offset
  9E60 SP1 - indexed by SP, 8 bit offset
    70 IX  - indexed by HX, no offset

Two operand addressing modes, by column
    A0 immediate
    B0 direct - 8 bit absolute
    C0 extended - 16 bit absolute
    D0 IX2 - indexed by HX, 16 bit offset
  9ED0 SP2 - indexed by SP, 16 bit offset
    E0 IX1 - indexed by HX, 8 bit offset
  9EE0 SP1 - indexed by SP, 8 bit offset
    F0 IX  - indexed by HX, no offset

We add the following "fake" column for instructions on H reg, of which
there are only three: clrh, pshh, pulh
For consistency we create an inherent ".h" mode.
    80 H reg
===========================================================================

( Addressing modes)

( The indexing words by default create two-op values. The one-op code has
  to convert them and check for illegal addressing modes.)

a0 constant imm
b0 constant dir
c0 constant ext
d0 constant ix2  9ed0 constant sp2
e0 constant ix1  9ee0 constant sp1
f0 constant ix

: u8?  ( u - u flag)  dup 100 u< ;  ( if unsigned value fits in 8 bits)
: s8?  ( n - n flag)  dup 80 + 100 u< ;  ( if signed offset fits into 8 bits)

assembler
: )   ( a - a op)  u8? if dir ^ then  ext ;
: #   ( n - n op)  imm ;
: ,s  ( offset - offset' op)
   ( adjusts offset by 1 since hardware stack is empty descending)
               1+  u8? if sp1 ^ then  sp2 ;
: ,x  ( offset - offset op | op)
   =if ( nonzero)  u8? if ix1 ^ then  ix2 ^ then  drop ( 0) ix ;

40 constant .a
50 constant .x
60 constant .h  ( fake column)
forth

: >col  ( col - index)  4 u>>  0f and ;

( Relative branches.)

( Branch offsets are relative to the _following_ instruction, which starts
  right after the offset, which is always the last byte.)

: >rel  ( dest - offset)  |here 1+ ( src)  -
   s8? not if error" relative branch out of range" then ;

: disp8,  >rel b, ;

forth
: inh  constant does> b, ; ( "inherent")
: stackop  constant does>  ( reg op)  swap \a .a - >col 2* + b, ;
assembler
80 inh rti
81 inh rts
( 82)
83 inh swi
84 inh tap
85 inh tpa
86 stackop pul
87 stackop psh
( 88-8b also stack ops)
forth
8c inh _clrh  ( .h clr)
assembler
( 8d)
8e inh stop
8f inh wait

( 90-93 are bge/blt/bgt/ble)
94 inh txs
95 inh tsx
( 96)
97 inh tax
98 inh clc
99 inh sec
9a inh cli
9b inh sei
9c inh rsp  ( reset stack pointer to 00FF - for HC05 compat)
9d inh nop
( 9e - prebyte for SP indexing, and fancy indexed modes for S08 ld/st/cphx)
9f inh txa


forth
: op,  u8? if b, ^ then  w, ;  ( output op, including pre-byte)
: ea,  ( col)  40 - >col  jump
   ( 40   50   60   70   80   90   a0   b0   c0   d0   e0   f0
     .a   .x   --   --   .h   --  imm  dir  ext  ix2  ix1   ix)
    nope nope ill  ill  ill  ill   b,   b,   w,   w,   b,  nope   [

( What 1colCheck is a bit subtle. Addressing modes that actually address
  memory, rather than specify a register, are represented by the column
  number in the address, including the possible pre-byte - or SP-relative
  modes - in the high byte. But not all modes that are allowed for 2ops are
  allowed for 1ops. So we have to check, convert it to the correct 1op
  column, and also dup it if necessary, so that after compiling the opcode
  we still have a reference to the address mode, so we can compile the
  correct bits after it!

  Laying it all out in a jump table makes it really simple to see what is
  going on.)

: ok  dup ;  ( ok as is; don't convert - this is already a 1col mode)
: cv  ( col - col2 col1)  dup  80 - ;  ( convert and dup)
: 1colCheck  ( col - 2col 1col | col)  ( make sure address mode is allowed)
   dup  40 - >col  jump
   ( 40   50   60   70   80   90   a0   b0   c0   d0   e0   f0
     .a   .x   --   --   .h   --  imm  dir  ext  ix2  ix1   ix)
     ok   ok  ill  ill  ill  ill  ill   cv  ill  ill   cv   cv   [

: 1op  constant does>  ( col row)  or  1colCheck  op, ea, ;
assembler
00 1op neg
forth
01 1op _cbeq ( special)
assembler
( 02 - mul, div, nsa, daa)
  42 inh mul
  52 inh div
  62 inh nsa  ( nybble swap accum)
  72 inh daa  ( decimal adjust accum)
03 1op com
04 1op lsr
( 05 - sthx, ldhx, cphx)
06 1op ror
07 1op asr
08 1op lsl
09 1op rol
0a 1op dec
forth
0b 1op _dbnz ( special)
assembler
0c 1op inc
0d 1op tst
( 0e - mov) 
forth
0f 1op _clr  ( so we can deal with .h clr special case)
assembler

( 1ops with special cases.)
: clr  dup \a .h = if  drop _clrh ^ then  _clr ;
: dbnz  _dbnz disp8, ;

forth
: 2op  constant does> ( 2col row)  or  dup op,  ea, ;
assembler
00 2op sub
01 2op cmp
02 2op sbc
03 2op cpx
04 2op and
05 2op bit
06 2op lda
07 2op sta  ( imm is ais)
08 2op eor
09 2op adc
0a 2op ora
0b 2op add
0c 2op jmp  ( no imm, no off s)
0d 2op jsr  ( bsr is imm, no off s)
0e 2op ldx
0f 2op stx  ( imm is aix)

: ais  ( n imm )  \a sta ;
: aix  ( n imm )  \a stx ;

forth
: bit  constant does> ( dir bit op)  swap 2* or  b, ( op)  b, ( dir) ;
( Note: These are _hex_ instruction values! The sets are even;
  the clrs are odd.)
00 bit _brset
01 bit _brclr
assembler
10 bit bset
11 bit bclr
: brset  _brset disp8, ;  ( these are branches, so compile the offset too)
: brclr  _brclr disp8, ;

forth
( Unlike in all the other assemblers I've seen or written, I'm writing the
  condition codes in their _positive_ sense - ie, 0< represents the BMI
  instruction, rather than its opposite, BPL. Things were done "backwards"
  traditionally because the semantics of "0< if w then" are to execute w
  when 0< is true; that is, S is set. But the BMI instruction is a _branch_
  if S set, so it would _skip_ a. Hence, the constants were traditionally
  defined to be the _opposite_ branch: BPL for 0<, BNE for =, BCC for u<,
  etc.

  I may change my mind about this. In any case, it's easy for the control
  flow words to negate the sense of the condition. For that matter, the
  cond defining word could do it, making _writing_ the assembler easier, in
  that it's easy to line up the condition _name_ with its value in the
  opcode  map, and let the assembler do the work of the negation, which is
  easy to get wrong.)

( Put this into _if_ rather than in the cond values. Less confusing.)
( Because we'll be using these in if/then, the condition represented is the
  _negative_ of the one in the opcode map.)

assembler
: not  ( cond - neg_cond)  1 xor ;
forth
: cond  \a not constant ;
assembler
02 cond u>  ( bhi      - C or Z clear; negation is bls)
05 cond u<  ( blo bcs  - C set; negation is bhs bcc)
07 cond =   ( beq      - Z set)
09 cond HC  ( bhcs     - HC set - half carry )
0b cond 0<  ( bmi  - S set)
0d cond I   ( bms  - I set - interrupt mask)
0f cond Q   ( bih  - irq pin high)
91 cond <   ( blt  - N xor V set)
92 cond >   ( bgt  - Z or [N xor V] clear)
comment ^^^
macro u<=  u> not ;m
macro u>=  u< not ;m
macro  <=   > not ;m
macro  >=   < not ;m  ^^^

( Control structures.)
( These are different from the pure Forth ones. Forward conditional branches
  are always _short_, but backwards branches can be short or long. A long
  branch is formed by inverting the condition to branch _around_ the
  longer branch.

  Thus we need words to compile forward conditional branches, forward
  unconditional branches, and backwards branches of either kind.)

: <resolve  ( dest src)  swap resolve> ;

( Compile a conditional jump; on entry stack has status bit, possibly or'ed
  with 400 to reverse its sense, so we should xor into opcode. By default
  opcode generated is jump if status bit _clear_.)

: cjmp,  ( statusbit - src)  f400 xor op,  |here ;

( Unconditional jmp)
: rjmp,   ( - src)  c000 op,  |here ;


( if compiles "branch if bit clr")
: if      (s bit - src)    cjmp, ;
: then    (s src)          |here resolve> ;
: else    (s src1 - src2)  rjmp, swap  \a then ;
: begin   (s - dest)       |here ;
: until   (s bit dest -)   \a if  <resolve ;
: again   (s dest -)       rjmp,  <resolve ;
: while   (s bit dest - src dest)   \a if  swap ;
: repeat  (s src dest -)   \a again  \a then ;

#]file

